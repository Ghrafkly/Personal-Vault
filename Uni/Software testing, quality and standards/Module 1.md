## 1. Software Testing

The are three main software development lifecycle (SDLC) models. These are:
![[1. Methodolgies.png]]

| Method               | Description                                                                                                                                                                                                                                            |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ðŸŒŠ Waterfall Model   | Traditional, sequential methodology in which the high-level tasks (i.e. requirements gathering, design, implementation, verification testing and maintenance) occur one after the other without revisiting a task once it is completed.     |
| ðŸŒ€ Spiral Model      | A more iterative method, in which the entire development 'cycle' is repeated a number of cycles. A working prototype is typically produced in each cycle.                                                                                   |
| ðŸ‘Ÿ Agile Method | A much more iterative method. It is the mainstream method that is widely used in industry nowadays. Agile is not a single methodology, but rather a broad term that summarises a set of software development principles, or best practices. |

Some of the key ideas for testing under the Agile Methodology are; Automated regression testing, Test-driven development (TDD), Continuous integration (CI). The objective of testing is to thoroughly identify and fix problems with the project before users are impacted by it. These problems can include:

- Defects or errors
- Performance bottlenecks
- Usability issues
- Security vulnerabilities 

## 2. Facets of Testing

### Types of Testing

| Type            | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Functionality   | A software would perform a number of functionalities based on the requirements of the client (business requirements). During testing, all the functionalities small or big must be tested. Though they only verify the output of an action and do not check the intermediate states of the system when performing an action.                                                                                                                                                                     |
| Usability       | this type of testing seems trivial but is significant to the client. You or your client will use a representative of the user group(s) to use the system while the facilitator observes and take notes of the representative's experience of using the system. A facilitator will take these notes back to the development team to improve usability of the system.                                                                                                                              |
| Security        | a must for software testing to find the vulnerabilities and risks in the system. Find the security related issues earlier in the development means you are able to prevent malicious attacks from intruders.                                                                                                                                                                                                                                                                                     |
| Reliability     | a process that checks whether the software can perform a failure-free operation for a given time. Through this process, you will find the frequency of failures & criticality of failures (Mean Time Between Failures)                                                                                                                                                                                                                                                                           |
| Efficiency      | Here, you want to check the behaviours of the system when it is under significant load (for example). Efficiency is subjective to each project and could be about performance, scalability to name a few. For example it can be observing response times when executing a high number of requests, or seeing how the system behaves with a significant of data. These tests are expensive to implement and run but they can help you understand if new changes are going to degrade your system. |
| Maintainability | It basically defines how easy it is to maintain the system. Includes how easy it is to analyse, change and test the system. You and your client will agree to some level of maintenance.                                                                                                                                                                                                                                                                                                         |
| Portability     | This is to determine the ease or difficulty with which a software component can be moved from one environment to another.                                                                                                                                                                                                                                                                                                                                                                        |
^types-of-testing
### Black Box Testing
Functional testing that focuses on the functionality of the system rather than knowledge of the code. Not knowing how the code is written is ideal for performing this testing. You have a set of inputs that you enter and have a set of expected output. If the expected output is the same as the actual output, the test has passed, otherwise, failed. For example: while signing up on Facebook, you need to enter a valid mobile number or email address. If you don't, you are not allowed to sign up. Now, imagine this validation was not available, the user could have entered anything as their contact information which would have made it nearly impossible for Facebook to verify your account.

### White Box Testing
Structural testing where internal structure and design of the system are known. The purpose of this testing is to verify the flow of input and output, to improve the quality of the code. This type of testing can also focus on improving security of the system when one of the testers acts as a white hacker. 

### Levels of Testing

| Level               | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| ------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Unit testing        | 'Unit' can be interpreted in several ways. A unit can be a single procedure, a function, a body of code that implements a single function, source code that fits on one page, work done between 2-20 hours or a single web page. In Java, generally a unit is a class. Whether it is black box or white box testing, in unit testing you are testing unit. In this unit you will learn methods used to perform unit testing in an object-oriented language. |
| Integration testing | Unfortunately, this level of testing is least understood to perform appropriately (read pg 229 of the book). Here, the idea is to combine the individual software modules and test them as a group. A methodical approach (top-down, bottom-up, sandwich and others) is required to form the groups. However, testers do not find the importance of using a method and end up finding bugs post-release.                                                    |
| System testing      | In this level of testing, we test the system based on our expectations, not specifications. In this unit, we will develop the concept of threads and Atomic System Function that will serve us understand thread-based system testing strategy.                                                                                                                                                                                                             |
| Acceptance testing  | Like unit testing, it has binary results, pass or fail. To note that, a failure suggests, though does not prove, the presence of a defect in the product. The more testing you do at different levels and types, the higher of finding the majority of the defects in the system. Acceptance testing is primarily user-focused to get the user to accept the features and their flow in the system.                                                         |
| Regression testing  | Regression testing is the process of testing the modified parts of the code and the parts that might get affected due to the modifications to ensure that no new errors have been introduced in the software after the modifications have been made. Regression means the return of something and in the software field, it refers to the return of a bug.                                                                                                  | 
^levels-of-testing
### Testing Approaches

* **Manual Approach**
	- Tester/QA: A designated tester or QA (Quality assurance) team performs all of the tests manually. The test cases are written down and marked as pass or fail by them. This approach is to report an error, not to identify the cause.
	- Human-driven: Imagine a person clicking everywhere on the system to discover the system's behaviour while testing.
	- This approach is suitable forÂ not-easily-repeatable-or-recordable testing: e.g. UI testing.
- **Automated Approach**
	- Regression testing is a great example of automated testing. You can set it auto-triggered and scheduled. For example: whenever a code is committed to the repository, the repository triggers a build. During build, all the tests are run again on the code. Successful build means all the tests have passed. If the build fails, you will find a comprehensive report to investigate failures. Some tests are developed by the developers, later you will learn about mutation testing where we will explore more on a relative topic.Â 
	- This is the go-to approach used in industry. 
